# F. 복사의 복사의 복사(Copy of a copy of a copy)

흑백 사진은 원소가 0과 1로만 이루어진 $n\times m$행렬이라고 생각할 수 있다. 각 행과 열은 각각 1부터 $n$까지 1부터 $m$으로 번호가 붙어져 있다. 

사진에는 한번에 두 가지 중 한 가지의 연산을 수행할 수 있다. 

* 가장자리에 있지 않은 원소 중 인접한 네 개의 원소가 모두 같은 색깔이고 자신과 다른 경우(만일 원소가 1이면 인접한 네 개 원소가 0이고 반대의 경우도 된다.)
* 사진의 인쇄본을 만든다.

연산의 순서는 임의대로이며 반드시 두 연산이 서로 번갈아 가며 진행해야 할 필요는 없다. 

당신은 이를 통해 $k$장의 사진을 추가로 얻게 될 것이다. 추가로 당신에게는 원본 사진도 주어져 있다. 그러나, 이 $k+1$장의 사진이 모두 섞여져 있다. (순서가 뒤죽박죽이다.)

연산의 순서를 기준으로 사진을 다시 배열하라. 만일 가능한 답이 여러가지라면 그 중 하나만 출력하여도 된다. 모든 테스트 케이스는 실제 연산의 나열을 통해 얻어낸 것으로 각 케이스마다 적어도 1개 이상의 답이 있음이 보장되어 있다.

** 입력 **

첫 번째 줄에는 각각 사진의 행과 열의 개수, 인쇄한 사진의 개수를 의미하는 $n,m,k$ ($3\leq m,n\leq 30, 0\leq k\leq 100$)가 주어진다.

그리고 인쇄된 사진 $k$장과 원본 사진을 포함해 $k+1$장의 사진이 주어진다. 이들의 순서는 임의대로 나열되어 있다. 

각 사진은 $m$개의 문자가 포함된 줄이 $n$개가 나열되어 있다. 각 사진이 주어지기 전에는 항상 빈 줄이 주어지는 것을 주의하라. 

** 출력 **

첫 번째 줄에는 원본 사진이 몇번째 줄에 있는지를 출력하라. <br/>
두 번째 줄에는 행한 연산 $q$의 개수를 출력하라.
<br/>
<br/>
다음 $q$줄동안은 각 줄마다 행한 연산에 대한 정보가 주어진다. 연산은 반드시 행한 순서에 따라 정렬되어 출력되어야 하고, 각 연산은<br/>

* $1\quad x\quad y\quad$ $(x,y)$의 색깔을 다시 칠한다. (이 원소는 사진의 $x$행의 $y$번째 원소이고 둘러싸인 이웃한 네 개의 칸은 반드시 색이 중앙의 색과 달라야 한다.)
* $2\quad i\quad$ 사진을 인쇄하고 $k+1$장 중 $i$번째 위치에 둔다. 1부터 $k+1$까지의 인덱스는 원본사진의 위치를 제외하고 반드시 1번씩 등장해야 한다.

만일, 복수의 정답이 있을 경우 그 중 아무거나 출력하라. 테스트 케이스는 실제 연산에 대해 만들어져 답이 항상 한 개 이상 있음은 보장되어 있다.

---
예시 케이스1
```
\\input
3 3 1

010
111
010

010
101
010
\\output
2
2
1 2 2
2 1
```
___
예시 케이스2
```
\\input
4 5 3

00000
01000
11100
01000

00000
01000
10100
01000

00000
01010
10100
01000

00000
01000
10100
01000

\\output
3
5
1 2 4
2 2
2 4
1 3 2
2 1
```
___
예시 케이스3
```
\\input
5 3 0

110
010
001
011
001

\\output
1
0
```

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({ tex2jax: {inlineMath: [['$', '$']]}, messageStyle: "none" });
</script>